// Including necessary libraries
#include <webots/robot.h>
#include <webots/motor.h>
#include <webots/distance_sensor.h>
#include <webots/gps.h>
#include <webots/light_sensor.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>

// Constants definition
#define TIME_STEP 64
#define MAX_SPEED 6.28
#define NUM_SENSORS 8
#define WALL_THRESHOLD 80.0
#define DEAD_END_THRESHOLD 50.0
#define DEAD_END_PROXIMITY 0.1
#define MAX_POSITIONS 5000
#define LIGHT_THRESHOLD 50.0
#define SMOOTHING_FACTOR 0.07

// Structure to store position and light intensity
typedef struct {
  double x, y, z;
  double light_intensity;
} PositionLightIntensity;

PositionLightIntensity recorded_positions[MAX_POSITIONS];
int recorded_position_count = 0;

// Structure to store detected dead ends
typedef struct {
  double x, y, z;
} DeadEnd;

DeadEnd detected_dead_ends[25];
int dead_end_count = 0;

// Calculate Euclidean distance between two 3D points
double calculate_distance(const double *pos1, const double *pos2) {
  return sqrt(pow(pos2[0] - pos1[0], 2) + pow(pos2[1] - pos1[1], 2) + pow(pos2[2] - pos1[2], 2));
}

// Detect dead end based on proximity values
bool detect_dead_end(double proximity_values[]) {
  return (proximity_values[7] > WALL_THRESHOLD &&
          proximity_values[1] > DEAD_END_THRESHOLD &&
          proximity_values[5] > DEAD_END_THRESHOLD);
}

// Check if the current position is a duplicate dead end
bool is_duplicate_dead_end(const double *position) {
  for (int i = 0; i < dead_end_count; i++) {
    double distance = calculate_distance(position,
                          (double[]){detected_dead_ends[i].x, detected_dead_ends[i].y, detected_dead_ends[i].z});
    if (distance < DEAD_END_PROXIMITY) {
      return true;
    }
  }
  return false;
}

// Smooth transition for motor speeds
double smooth_speed(double current, double target) {
  return current + SMOOTHING_FACTOR * (target - current);
}

int main() {
  wb_robot_init();

  // Set up motors
  WbDeviceTag right_motor = wb_robot_get_device("right wheel motor");
  WbDeviceTag left_motor = wb_robot_get_device("left wheel motor");
  wb_motor_set_position(right_motor, INFINITY);
  wb_motor_set_position(left_motor, INFINITY);
  wb_motor_set_velocity(right_motor, 0.0);
  wb_motor_set_velocity(left_motor, 0.0);

  // Set up sensors
  WbDeviceTag proximity_sensors[8], light_sensors[NUM_SENSORS], gps;
  char sensor_name[50];

  for (int i = 0; i < 8; i++) {
    sprintf(sensor_name, "ps%d", i);
    proximity_sensors[i] = wb_robot_get_device(sensor_name);
    wb_distance_sensor_enable(proximity_sensors[i], TIME_STEP);
  }

  for (int i = 0; i < NUM_SENSORS; i++) {
    sprintf(sensor_name, "ls%d", i);
    light_sensors[i] = wb_robot_get_device(sensor_name);
    wb_light_sensor_enable(light_sensors[i], TIME_STEP);
  }

  gps = wb_robot_get_device("gps");
  wb_gps_enable(gps, TIME_STEP);

  // Initialize motor speeds and robot's initial position
  double right_speed = MAX_SPEED;
  double left_speed = MAX_SPEED;

  // Main control loop
  while (wb_robot_step(TIME_STEP) != -1) {
    double proximity_values[8], light_sum = 0.0;
    const double *current_position = wb_gps_get_values(gps);

    // Read proximity sensor values
    for (int i = 0; i < 8; i++) {
      proximity_values[i] = wb_distance_sensor_get_value(proximity_sensors[i]);
    }

    // Read light sensor values
    for (int i = 0; i < NUM_SENSORS; i++) {
      light_sum += wb_light_sensor_get_value(light_sensors[i]);
    }
    double average_light = light_sum / NUM_SENSORS;

    // Dead-end detection
    if (detect_dead_end(proximity_values)) {
      if (!is_duplicate_dead_end(current_position)) {
        printf("Dead End Detected at (%.2f, %.2f, %.2f), Light: %.2f\n",
               current_position[0], current_position[1], current_position[2], average_light);

        // Record the dead end
        detected_dead_ends[dead_end_count++] = (DeadEnd){current_position[0], current_position[1], current_position[2]};

        // Reverse and reorient
        right_speed = -MAX_SPEED / 2;
        left_speed = -MAX_SPEED / 2;
        wb_motor_set_velocity(right_motor, right_speed);
        wb_motor_set_velocity(left_motor, left_speed);
        wb_robot_step(10 * TIME_STEP); // Reverse for some time

        right_speed = MAX_SPEED;
        left_speed = -MAX_SPEED;
        wb_motor_set_velocity(right_motor, right_speed);
        wb_motor_set_velocity(left_motor, left_speed);
        wb_robot_step(15 * TIME_STEP); // Reorient
      }
    } else {
      // Wall-following behavior
      bool front_wall = proximity_values[7] > WALL_THRESHOLD;
      bool left_wall = proximity_values[1] > WALL_THRESHOLD;

      if (front_wall) {
        right_speed = MAX_SPEED;
        left_speed = -MAX_SPEED; // Turn right
      } else if (left_wall) {
        right_speed = MAX_SPEED;
        left_speed = MAX_SPEED; // Go straight
      } else {
        right_speed = MAX_SPEED / 4;
        left_speed = MAX_SPEED; // Turn left
      }
    }

    // Smooth motor transitions and set speeds
    right_speed = smooth_speed(right_speed, MAX_SPEED);
    left_speed = smooth_speed(left_speed, MAX_SPEED);
    wb_motor_set_velocity(right_motor, right_speed);
    wb_motor_set_velocity(left_motor, left_speed);

    // Print position and light intensity
    printf("Position: (%.2f, %.2f, %.2f), Light: %.2f\n",
           current_position[0], current_position[1], current_position[2], average_light);
  }

  wb_robot_cleanup();
  return 0;
}
